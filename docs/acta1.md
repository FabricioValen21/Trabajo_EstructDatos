

ACTA DE REUNION


El dia martes 3 de junio del 2025 a las 8:00 p.m., los integrantes del grupo conformado por Luis Mario Huillca Quispe, Gary Jhoel Choquehuanca Yupanqui, Fabricio Alans Valencia Hañari, Juan Carlos Cuti Muñoz y Nicolas Anderson Champi Palacios nos reunimos como parte de la sesión correspondiente al curso de Estructura de Datos para trabajar en el desarrollo del proyecto grupal. Durante esta reunión se desarrolló el Capítulo 1 del informe, correspondiente al análisis del problema. En esta etapa se planteó como objetivo principal simular un sistema operativo básico capaz de gestionar procesos en diferentes estados como listo, en ejecución, bloqueado y terminado, utilizando estructuras de datos implementadas manualmente para comprender su funcionamiento interno.

Durante la sesión analizamos en detalle la problemática y definimos los requerimientos del sistema. En cuanto a los requerimientos funcionales, se estableció que el sistema debe permitir la creación de procesos con nombre, ID, prioridad y duración, almacenarlos según su estado en estructuras adecuadas, cambiar su estado en función de eventos simulados, asignar y liberar memoria, gestionarlos por prioridad (alta, media, baja), eliminarlos o suspenderlos manualmente, visualizar su estado actual y manejar los procesos suspendidos mediante una pila, permitiendo restaurarlos cuando sea necesario. En cuanto a los requerimientos no funcionales, acordamos que la interfaz será por consola, clara y funcional, y que no se utilizarán estructuras estándar de bibliotecas como vector, queue o list.

También dejamos definidas las estructuras de datos que usaremos en la implementación. Para el gestor de procesos se utilizará una lista enlazada simple que permitirá insertar nuevos procesos al final, eliminarlos por ID, buscar por ID o nombre y modificar atributos como prioridad o duración. El planificador de CPU funcionará con una cola de prioridad implementada manualmente mediante inserción ordenada según prioridad fija. Esta permitirá encolar procesos según prioridad, desencolarlos para simular su ejecución y visualizar el contenido actual. El gestor de memoria se implementará como una pila bajo una política LIFO para asignar memoria con push al crear un proceso y liberar memoria con pop al finalizar. Finalmente, la cola de procesos bloqueados será una estructura FIFO donde se encolarán los procesos que esperan por eventos simulados y se desencolarán cuando se cumplan las condiciones.

La reunión concluyó con un acuerdo general sobre los elementos clave del proyecto y la organización del trabajo a realizar en las siguientes sesiones.
